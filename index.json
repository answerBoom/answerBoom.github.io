[{"content":"扩散模型学习笔记 思路 训练个数为T（时刻数）的神经网络模型。通过正向扩散获得每个时刻t的均值和方差。利用重参数化技巧，将随机性转移到$\\epsilon$上，整个过程看作是马尔可夫过程，每个时刻的分布如下图所示。根据下列公式可以得到任意时刻的$q(x_t|x_{t-1})$\n学习$p_\\theta$去近似q()，根据贝叶斯可以算出逆向过程q的均值和方差：\n上述公式的均值为$b\\over -2a$，方差为$1\\over a$,计算p的对数损失，使其最大，\n经过简化后的对数损失，且因为方差是常数，可优化的只有均值： 最后。学习一个$\\epsilon_\\theta$去逼近$\\epsilon_t$\n重参数化技巧 在高斯分布$\\aleph(\\mu,sigma^2)$中采样是一个随机过程，不能进行反向传播梯度，可以先从标准分布$\\aleph(0，1)$中采样，得到$\\sigma*\\epsilon+\\mu$将随机性转移到这个$\\epsilon$常量上\n1.导入数据 %matplotlib inline import matplotlib.pyplot as plt import numpy as np from sklearn.datasets import make_s_curve import torch s_curve,_ = make_s_curve(10**4,noise=0.1) s_curve = s_curve[:,[0,2]]/10.0 print(\u0026#34;shape of s:\u0026#34;,np.shape(s_curve)) #样本维度转化为特征维度 data = s_curve.T fig,ax = plt.subplots() ax.scatter(*data,color=\u0026#39;blue\u0026#39;,edgecolor=\u0026#39;white\u0026#39;); ax.axis(\u0026#39;off\u0026#39;) dataset = torch.Tensor(s_curve).float() 2. 确定超参数的值 num_steps = 100 #制定每一步的beta betas = torch.linspace(-6,6,num_steps) betas = torch.sigmoid(betas)*(0.5e-2 - 1e-5)+1e-5 #计算alpha、alpha_prod、alpha_prod_previous、alpha_bar_sqrt等变量的值 alphas = 1-betas alphas_prod = torch.cumprod(alphas,0) alphas_prod_p = torch.cat([torch.tensor([1]).float(),alphas_prod[:-1]],0) alphas_bar_sqrt = torch.sqrt(alphas_prod) one_minus_alphas_bar_log = torch.log(1 - alphas_prod) one_minus_alphas_bar_sqrt = torch.sqrt(1 - alphas_prod) assert alphas.shape==alphas_prod.shape==alphas_prod_p.shape==\\ alphas_bar_sqrt.shape==one_minus_alphas_bar_log.shape\\ ==one_minus_alphas_bar_sqrt.shape print(\u0026#34;all the same shape\u0026#34;,betas.shape) 3. 确定扩散过程任意时刻的采样值 #计算任意时刻的x采样值，基于x_0和重参数化 def q_x(x_0,t): \u0026#34;\u0026#34;\u0026#34;可以基于x[0]得到任意时刻t的x[t]\u0026#34;\u0026#34;\u0026#34; noise = torch.randn_like(x_0) alphas_t = alphas_bar_sqrt[t] alphas_1_m_t = one_minus_alphas_bar_sqrt[t] return (alphas_t * x_0 + alphas_1_m_t * noise)#在x[0]的基础上添加噪声 4. 定义网络模型 import torch import torch.nn as nn class MLPDiffusion(nn.Module): def __init__(self,n_steps,num_units=128): super(MLPDiffusion,self).__init__() self.linears = nn.ModuleList( [ nn.Linear(2,num_units), nn.ReLU(), nn.Linear(num_units,num_units), nn.ReLU(), nn.Linear(num_units,num_units), nn.ReLU(), nn.Linear(num_units,2), ] ) self.step_embeddings = nn.ModuleList( [\t# 定义一个大小为时间t，维度为128的查询表 nn.Embedding(n_steps,num_units), nn.Embedding(n_steps,num_units), nn.Embedding(n_steps,num_units), ] ) def forward(self,x,t): # x = x_0 for idx,embedding_layer in enumerate(self.step_embeddings): t_embedding = embedding_layer(t) # 2*idx 表示通过索引 idx 访问模块列表中的线性层，因为每个线性层后面紧跟着一个激活函数层。0、2、4 x = self.linears[2*idx](x) x += t_embedding x = self.linears[2*idx+1](x) x = self.linears[-1](x) return x embedding的理解 embedding = nn.Embedding(embeddings_nums,embeddings_dim) # 例如（5，3） \u0026#34;\u0026#34;\u0026#34; print(embedding): tensor([[-1.8056, 0.1836, -1.4376], [ 0.8409, 0.1034, -1.3735], [-1.3317, 0.8350, -1.7235], [ 1.5251, -0.2363, -0.6729], [ 0.4148, -0.0923, 0.2459]], requires_grad=True) \u0026#34;\u0026#34;\u0026#34; embeddings_nums：查询表的大小 embeddings_dim：每个查询向量的维度 定义一个具有embeddings_nums个单词，维度为dim的查询矩阵\nout = embdding(0) # 表示获取查询矩阵中ID为0的查询向量 # out = [-1.8056, 0.1836, -1.4376] 5. 训练的误差函数 逆向过程算出的均值和模型预测出的均值算了个均方误差，展开成噪声的均方误差\ndef diffusion_loss_fn(model,x_0,alphas_bar_sqrt,one_minus_alphas_bar_sqrt,n_steps): \u0026#34;\u0026#34;\u0026#34;对任意时刻t进行采样计算loss\u0026#34;\u0026#34;\u0026#34; batch_size = x_0.shape[0] #对一个batchsize样本生成随机的时刻t t = torch.randint(0,n_steps,size=(batch_size//2,)) t = torch.cat([t,n_steps-1-t],dim=0) #[batch_size] t = t.unsqueeze(-1)\t#[batch_size] \u0026#34;\u0026#34;\u0026#34; print(t.shape)为(128,1) \u0026#34;\u0026#34;\u0026#34; #x0的系数 a = alphas_bar_sqrt[t] # a.shape为(128,1) #eps的系数 aml = one_minus_alphas_bar_sqrt[t] #生成随机噪音eps e = torch.randn_like(x_0) #构造模型的输入 #这里x的维度为(128，2)，a的维度为(128,1),维度相同才能进行*，若不对t.unsqueeze(-1)，则a的维度为(128)，不能进行运算 x = x_0*a+e*aml #送入模型，得到t时刻的随机噪声预测值 output = model(x,t.squeeze(-1)) #与真实噪声一起计算误差，求平均值 return (e - output).square().mean() 6. 逆扩散采样函数（inference） def p_sample_loop(model,shape,n_steps,betas,one_minus_alphas_bar_sqrt): \u0026#34;\u0026#34;\u0026#34;从x[T]恢复x[T-1]、x[T-2]|...x[0]\u0026#34;\u0026#34;\u0026#34; cur_x = torch.randn(shape) x_seq = [cur_x] for i in reversed(range(n_steps)): cur_x = p_sample(model,cur_x,i,betas,one_minus_alphas_bar_sqrt) x_seq.append(cur_x) return x_seq def p_sample(model,x,t,betas,one_minus_alphas_bar_sqrt): \u0026#34;\u0026#34;\u0026#34;从x[T]采样t时刻的重构值\u0026#34;\u0026#34;\u0026#34; t = torch.tensor([t]) coeff = betas[t] / one_minus_alphas_bar_sqrt[t] eps_theta = model(x,t) mean = (1/(1-betas[t]).sqrt())*(x-(coeff*eps_theta)) z = torch.randn_like(x) sigma_t = betas[t].sqrt() sample = mean + sigma_t * z return (sample) 7. 开始训练模型 seed = 1234 class EMA(): \u0026#34;\u0026#34;\u0026#34;构建一个参数平滑器\u0026#34;\u0026#34;\u0026#34; def __init__(self,mu=0.01): self.mu = mu self.shadow = {} def register(self,name,val): self.shadow[name] = val.clone() def __call__(self,name,x): assert name in self.shadow new_average = self.mu * x + (1.0-self.mu)*self.shadow[name] self.shadow[name] = new_average.clone() return new_average print(\u0026#39;Training model...\u0026#39;) batch_size = 128 dataloader = torch.utils.data.DataLoader(dataset,batch_size=batch_size,shuffle=True) num_epoch = 4000 plt.rc(\u0026#39;text\u0026#39;,color=\u0026#39;blue\u0026#39;) model = MLPDiffusion(num_steps)#输出维度是2，输入是x和step optimizer = torch.optim.Adam(model.parameters(),lr=1e-3) for t in range(num_epoch): for idx,batch_x in enumerate(dataloader): loss = diffusion_loss_fn(model,batch_x,alphas_bar_sqrt,one_minus_alphas_bar_sqrt,num_steps) optimizer.zero_grad() loss.backward() torch.nn.utils.clip_grad_norm_(model.parameters(),1.) optimizer.step() if(t%100==0): print(loss) x_seq = p_sample_loop(model,dataset.shape,num_steps,betas,one_minus_alphas_bar_sqrt) fig,axs = plt.subplots(1,10,figsize=(28,3)) for i in range(1,11): cur_x = x_seq[i*10].detach() axs[i-1].scatter(cur_x[:,0],cur_x[:,1],color=\u0026#39;red\u0026#39;,edgecolor=\u0026#39;white\u0026#39;); axs[i-1].set_axis_off(); axs[i-1].set_title(\u0026#39;$q(\\mathbf{x}_{\u0026#39;+str(i*10)+\u0026#39;})$\u0026#39;) 参数平滑器 ​\t上述代码定义了一个参数平滑器 EMA，用于对模型的参数进行平滑处理。该类的主要功能是维护一个影子参数字典 shadow，其中保存了每个参数的平滑后的数值。\n​\t构造函数 __init__ 中接收一个参数 mu，用于控制平滑的程度，默认为 0.01。\n​\tregister 方法用于注册参数，将参数的名称和初始值保存到影子参数字典 shadow 中。\n​\t__call__ 方法用于对指定参数进行平滑处理。它接收参数名称 name 和参数值 x，首先检查参数名称是否存在于影子参数字典 shadow 中，然后根据指定的平滑系数 mu，计算新的平滑参数值 new_average，并更新影子参数字典中的对应数值。最后返回新的平滑参数值。\n​\t通过使用 EMA 类，可以实现对模型参数的平滑更新，使模型在训练过程中的参数变化更加平缓。这可以有助于提高模型的稳定性和收敛性。\n训练过程 ​\ttorch.nn.utils.clip_grad_norm_ 是一个用于梯度裁剪的函数，它可以帮助限制梯度的范数，防止梯度爆炸问题。clip_grad_norm_ 函数接受两个参数：parameters 和 max_norm。parameters 是模型的参数列表，而 max_norm 是用于裁剪梯度的最大范数值。\n​\t在代码中，torch.nn.utils.clip_grad_norm_(model.parameters(), 1.) 表示对模型的所有参数进行梯度裁剪，将梯度的范数限制在 1.0 内。这样可以确保梯度不会过大，避免训练过程中的不稳定性。\n​\t接下来，optimizer.step() 是优化器的一个方法，用于更新模型的参数。它根据计算得到的梯度来更新参数，使模型向更好的方向前进。通过执行 optimizer.step()，可以使模型在训练过程中不断优化和更新。\n认识dataloader dataloader = torch.utils.data.DataLoader(dataset,batch_size=batch_size,shuffle=True) ​\ttorch.utils.data.DataLoader 是 PyTorch 中用于加载数据的工具类。在给定数据集 dataset 的情况下，DataLoader 可以帮助我们以指定的批量大小 batch_size 加载数据，并提供一些额外的功能，如数据打乱（通过设置 shuffle=True）和并行加载数据。\n​\t具体来说，上述代码创建了一个 DataLoader 对象 dataloader，它将数据集 dataset 分成以 batch_size 为大小的批次。设置 shuffle=True 表示在每个 epoch 中对数据进行打乱，以增加数据的随机性。\n​\t通过使用 dataloader，我们可以轻松地迭代遍历数据集，每次迭代获得一个批次的数据，方便进行训练或推断操作。\n参考 [什么是扩散模型？ |利尔日志 (lilianweng.github.io)](https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#:~:text=Diffusion models are inspired by non-equilibrium thermodynamics. They,to construct desired data samples from the noise.)\nProbabilistic Diffusion Model概率扩散模型理论与完整PyTorch代码详细解读_哔哩哔哩_bilibili\ndeep_thoughts的扩散模型笔记 (bilibili.com)\n","permalink":"answerboom.github.io/articles/2023/07/27/diffusion-models-note/","summary":"扩散模型学习笔记 思路 训练个数为T（时刻数）的神经网络模型。通过正向扩散获得每个时刻t的均值和方差。利用重参数化技巧，将随机性转移到$\\epsilon$上，整个过程看作是马尔可夫过程，每个时刻的分布如下图所示。根据下列公式可以得到任意时刻的$q(x_t|x_{t-1})$\n学习$p_\\theta$去近似q()，根据贝叶斯可以算出逆向过程q的均值和方差：\n上述公式的均值为$b\\over -2a$，方差为$1\\over a$,计算p的对数损失，使其最大，\n经过简化后的对数损失，且因为方差是常数，可优化的只有均值： 最后。学习一个$\\epsilon_\\theta$去逼近$\\epsilon_t$\n重参数化技巧 在高斯分布$\\aleph(\\mu,sigma^2)$中采样是一个随机过程，不能进行反向传播梯度，可以先从标准分布$\\aleph(0，1)$中采样，得到$\\sigma*\\epsilon+\\mu$将随机性转移到这个$\\epsilon$常量上\n1.导入数据 %matplotlib inline import matplotlib.pyplot as plt import numpy as np from sklearn.datasets import make_s_curve import torch s_curve,_ = make_s_curve(10**4,noise=0.1) s_curve = s_curve[:,[0,2]]/10.0 print(\u0026#34;shape of s:\u0026#34;,np.shape(s_curve)) #样本维度转化为特征维度 data = s_curve.T fig,ax = plt.subplots() ax.scatter(*data,color=\u0026#39;blue\u0026#39;,edgecolor=\u0026#39;white\u0026#39;); ax.axis(\u0026#39;off\u0026#39;) dataset = torch.Tensor(s_curve).float() 2. 确定超参数的值 num_steps = 100 #制定每一步的beta betas = torch.linspace(-6,6,num_steps) betas = torch.sigmoid(betas)*(0.5e-2 - 1e-5)+1e-5 #计算alpha、alpha_prod、alpha_prod_previous、alpha_bar_sqrt等变量的值 alphas = 1-betas alphas_prod = torch.cumprod(alphas,0) alphas_prod_p = torch.","title":"扩散模型"},{"content":"$ git commit -m \u0026ldquo;first commit\u0026quot;错误 丢失或跳过git add .或git commit可能导致此错误：\n$ git commit -m \u0026#34;first commit\u0026#34; On branch main Initial commit Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) .gitignore README.md _config.butterfly.yml _config.yml gulpfile.js package.json repoPic/ scaffolds/ source/ themes/ nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) $ git push -u origin main错误 error: src refspec main does not match any error: failed to push some refs to \u0026#39;https://github.com 此错误最可能的原因是所有文件都未跟踪且未添加。 git add \u0026ndash;all 如果你想添加所有文件或者你可以有选择地添加文件。 然后 git commit -m \u0026ldquo;Initial comment\u0026rdquo;, git push origin master。\n解决方法 要修复它，请重新初始化并遵循正确的顺序：\ngit init git add --all/git add . $ git remote add origin https://github.com git commit -m \u0026#34;Initial comment\u0026#34; git push -u origin main 参考：message-src-refspec-master-does-not-match-any-when-pushing-commits-in-git\n","permalink":"answerboom.github.io/articles/2023/06/08/github-error/","summary":"$ git commit -m \u0026ldquo;first commit\u0026quot;错误 丢失或跳过git add .或git commit可能导致此错误：\n$ git commit -m \u0026#34;first commit\u0026#34; On branch main Initial commit Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) .gitignore README.md _config.butterfly.yml _config.yml gulpfile.js package.json repoPic/ scaffolds/ source/ themes/ nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) $ git push -u origin main错误 error: src refspec main does not match any error: failed to push some refs to \u0026#39;https://github.","title":"Github Error"},{"content":"vscode启动和部署 需要先设置vscode权限 get-ExectionPolicy set-ExecutionPolicy RemoteSigned 本地启动hexo hexo s 部署到github npm install hexo-deployer-git --save hexo clean \u0026amp;\u0026amp; hexo generate \u0026amp;\u0026amp; hexo deploy // Git BASH终端 hexo clean; hexo generate; hexo deploy // VSCODE终端 修改 _config.yml 文件 在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为main代表主分支（注意缩进）。\ndeploy: type: git repository: git@github.com:answer/answer.github.io.git branch: main hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。 hexo generate：生成静态文章，可以用hexo g缩写 hexo deploy：部署文章，可以用hexo d缩写 vscode推送项目到GitHub仓库 https://www.fomal.cc/posts/e593433d.html\n","permalink":"answerboom.github.io/articles/2023/06/08/hexonote/","summary":"vscode启动和部署 需要先设置vscode权限 get-ExectionPolicy set-ExecutionPolicy RemoteSigned 本地启动hexo hexo s 部署到github npm install hexo-deployer-git --save hexo clean \u0026amp;\u0026amp; hexo generate \u0026amp;\u0026amp; hexo deploy // Git BASH终端 hexo clean; hexo generate; hexo deploy // VSCODE终端 修改 _config.yml 文件 在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为main代表主分支（注意缩进）。\ndeploy: type: git repository: git@github.com:answer/answer.github.io.git branch: main hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。 hexo generate：生成静态文章，可以用hexo g缩写 hexo deploy：部署文章，可以用hexo d缩写 vscode推送项目到GitHub仓库 https://www.fomal.cc/posts/e593433d.html","title":"Hexo学习记录"},{"content":" 学习风格迁移算法，第一次连接服务器运行深度学习代码，如何使用conda、jupter\n服务器上跑深度学习代码 一、 连接服务器 （1）用户名密码 （2）linux操作 pwd：查看当前所在路径 watch nvidia-smi：查看显卡情况 top：查看cpu使用情况 df -h：查看磁盘空间 wget URL：下载文件 （3）conda操作 conda env list：列出所有环境 activate env-name：激活环境 conda list：查看当前环境中安装的包 conda env create -f environment.yaml --prefix /media/s304/Data/condaenv/Inst：根据文件创建环境并指定路径 二、 pycharm远程连接服务器 设置Connection 建立mapping 设置excluded paths 设置代码自动上传（Options） 设置python Interpreter 其他功能 打开服务器的terminal(可开多个)：Tools-Start SSH session 查看服务器文件：Tools-Development-Browse Remote Host 如果有参数，可以在edit configurations中设置parameters 三、遇到的问题 1. 跑代码的过程中cpu使用率较高，而gpu使用率为0 ​\t解决方法：tensorflow-gpu版本问题、以及版本冲突问题，重新下包后解决。\n风格迁移 fast-transfer python style.py --style data/style/style1.jpg \\ --checkpoint-dir data/checkpoints \\ --test data/content/girlandforest.jpg \\ --test-dir data/result \\ --content-weight 1.5e1 \\ --checkpoint-iterations 1000 \\ --batch-size 20 python style.py --style data/style/style1.jpg --checkpoint-dir data/checkpoints --test data/content/girlandforest.jpg --test-dir data/result --content-weight 1.5e1 --checkpoint-iterations 1000 --batch-size 20 --style：样式图像的路径。必需的。 --checkpoint-dir: 保存检查点的目录。必填 --test：在每次检查点迭代时测试网络的内容图像路径。默认值：无图像。 --test-dir：保存测试图像的目录路径。如果--test传递了一个值，则为必需。 --batch_size：训练的批量大小。默认值：4. --vgg-path：VGG19 网络的路径（默认）。如果你想尝试其他损失函数，可以通过 VGG16。默认值：data/imagenet-vgg-verydeep-19.mat. \\：换行 Inst-main python main.py --base configs/stable-diffusion/v1-finetune.yaml -t --actual_resume ./models/sd/sd-v1-4.ckpt -n \u0026lt;run_name\u0026gt; --gpus 0, --data_root /train-images 提供的命令执行了一个名为 main.py 的 Python 脚本，带有以下参数：\n--base：指定脚本的基本配置文件。在这种情况下，文件路径为 configs/stable-diffusion/v1-finetune.yaml。\n-t：一个标志，表示您要以测试模式运行脚本。\n--actual_resume：指定要从中恢复训练的检查点文件的路径。在这种情况下，文件路径为 ./models/sd/sd-v1-4.ckpt。\n-n：为运行指定一个名称。\n--gpus：指定要用于训练的 GPU。在这种情况下，选择了 GPU 0。\n--data_root：指定包含图像的目录的路径。在这种情况下，目录路径为 /path/to/directory/with/images。\n遇到的问题 RuntimeError: CUDA out of memory. Tried to allocate 512.00 MiB (GPU 0; 10.92 GiB total capacity; 9.66 GiB already allocated; 418.75 MiB free; 9.69 GiB reserved in total by PyTorch) If reserved memory is \u0026gt;\u0026gt; allocated memory try setting max_split_size_mb to avoid fragmentation. See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF 运行时错误：CUDA内存不足。尝试分配512.00 MiB的显存（GPU 0；总容量为10.92 GiB；已分配9.66 GiB；剩余418.75 MiB可用；PyTorch总共保留了9.69 GiB的显存）。如果保留的内存 \u0026raquo; 分配的内存，请尝试设置max_split_size_mb来避免碎片化。请参阅内存管理和PYTORCH_CUDA_ALLOC_CONF文档。\n解决方法：调整输入图像大小512-》256\n远程连接jupter 在服务器上输入jupyter notebook 在本机cmd中输入：ssh -L localhost:8888:localhost:8889 s304@172.17.172.128 访问localhost:8888 ","permalink":"answerboom.github.io/articles/2023/05/30/styletransfer/","summary":"学习风格迁移算法，第一次连接服务器运行深度学习代码，如何使用conda、jupter\n服务器上跑深度学习代码 一、 连接服务器 （1）用户名密码 （2）linux操作 pwd：查看当前所在路径 watch nvidia-smi：查看显卡情况 top：查看cpu使用情况 df -h：查看磁盘空间 wget URL：下载文件 （3）conda操作 conda env list：列出所有环境 activate env-name：激活环境 conda list：查看当前环境中安装的包 conda env create -f environment.yaml --prefix /media/s304/Data/condaenv/Inst：根据文件创建环境并指定路径 二、 pycharm远程连接服务器 设置Connection 建立mapping 设置excluded paths 设置代码自动上传（Options） 设置python Interpreter 其他功能 打开服务器的terminal(可开多个)：Tools-Start SSH session 查看服务器文件：Tools-Development-Browse Remote Host 如果有参数，可以在edit configurations中设置parameters 三、遇到的问题 1. 跑代码的过程中cpu使用率较高，而gpu使用率为0 ​\t解决方法：tensorflow-gpu版本问题、以及版本冲突问题，重新下包后解决。\n风格迁移 fast-transfer python style.py --style data/style/style1.jpg \\ --checkpoint-dir data/checkpoints \\ --test data/content/girlandforest.jpg \\ --test-dir data/result \\ --content-weight 1.","title":"风格迁移"},{"content":"blog项目笔记 mybatis plus 1. 类注解 @Data @NoArgsConstructor @AllArgsConstructor @TableName(\u0026#34;sg_article\u0026#34;) @Accessors(chain = true) public class Article{ } @Data：注在类上，提供类的get、set、equals、hashCode、toString方法\n@NoArgsConstructor：提供类的无参构造\n@AllArgsConstructor：提供类的全参构造\n@TableName(\u0026quot;sg_article\u0026quot;)：将表与数据库里的表对应起来\n@Accessors(chain = true)：将get、set方法的返回类型设置为实体类对象，代替了默认的返回void\n实体类中加入数据库中不存在的列名需要加入TableField注解标识\n@TableField(exist = false) private String categoryName; 2. mybatis plus中wapper方法 queryWapper.eq（字段名，val）\n字段名可以用字符串也可以用方法：Article::getStatus\n推荐用方法防止列名写错\nlambdaQueryWrapper.eq(Objects.nonNull(categoryId) \u0026amp;\u0026amp; categoryId \u0026gt; 0, Article::getCategoryId, categoryId);\neq方法中有三个参数，第一个boolean为true时引入加入后两个参数条件，为false时不加入\n3. 使用page分页需要配置分页插件，在config包下加入以下类 @Configuration public class MbatisPlusConfig { /** * 3.4.0之后版本 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; } } 4、公共字段填充 插入时间、更新时间的自动填充\n1、在实体类的属性上加入@TableField注解，指定自动填充的策略\n2、按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口\n@TableField(fill=FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill=FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { metaObject.setValue(\u0026#34;createTime\u0026#34;, LocalDateTime.now()); metaObject.setValue(\u0026#34;updateTime\u0026#34;, LocalDateTime.now()); metaObject.setValue(\u0026#34;createUser\u0026#34;,new Long(1)); metaObject.setValue(\u0026#34;updateUser\u0026#34;,new Long(1)); } @Override public void updateFill(MetaObject metaObject) { metaObject.setValue(\u0026#34;updateTime\u0026#34;, LocalDateTime.now()); metaObject.setValue(\u0026#34;updateUser\u0026#34;,new Long(1)); } } 5、@Transactional ​\t涉及多张表操作的方法需要加入@Transactional注解，并在启动类上加入@EnableTransactionManagement注解\nStrem流 1.map、filter Stream流中，map可以将一个流的元素按照一定的映射规则映射到另一个流中。\npublic static \u0026lt;O,T\u0026gt; List\u0026lt;T\u0026gt; copyBeanList(List\u0026lt;O\u0026gt; list,Class\u0026lt;T\u0026gt; clazz) { return list.stream() .map(o -\u0026gt; copyBean(o,clazz)).collect(Collectors.toList()); } lambda是对匿名内部类的一种简写\ncategories = categories.stream().filter(new Predicate\u0026lt;Category\u0026gt;() { @Override public boolean test(Category category) { return SystemConstants.STATUS_NORMAL.equals(category.getStatus()); } }).collect(Collectors.toList()); 简写后\nList\u0026lt;category\u0026gt; categories = categories.stream().filter(category -\u0026gt; SystemConstants.STATUS_NORMAL.equals(category.getStatus())).collect(Collectors.toList()); filter过滤掉不满足表达式的元素\ncollect操作可以接受各种方法作为参数，将流中的元素汇集。\n2.演变过程 将分类表name根据categoryId赋值给Article的categoryName\n使用匿名内部类\narticles.stream().map(new Function\u0026lt;Article, Article\u0026gt;() { @Override public Article apply(Article article) { //获取分类id，查询分类信息，获取分类名称 Category category = categoryService.getById(article.getCategoryId()); String name = category.getName(); article.setCategoryName(name); return article; } }) 使用lambda表达式\n只关注参数列表和方法体\n(Article article) { //获取分类id，查询分类信息，获取分类名称 Category category = categoryService.getById(article.getCategoryId()); String name = category.getName(); article.setCategoryName(name); return article; } 参数列表和方法体用一个箭头，如果只有一个参数则参数类型、小括号可以省略，大括号和return可以去掉\narticles.stream().map(article -\u0026gt; Category category = categoryService.getById(article.getCategoryId()); String name = category.getName(); article.setCategoryName(name); return article; ) 简化完成后\narticles = articles.stream() .map(article -\u0026gt; article.setCategoryName(categoryService.getById(article.getCategoryId()).getName())).collect(Collectors.toList()); Spring Security 加入依赖\n\u0026lt;!--SpringSecurity启动器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--redis依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--fastjson依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jwt依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 加入工具类和配置\n登录 ​\t①自定义登录接口\n​\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\n​\t把用户信息存入redis中\n​\t②自定义UserDetailsService\n​\t在这个实现类中去查询数据库\n​\t注意配置passwordEncoder为BCryptPasswordEncoder\n将authenticationManager注入容器\n@Autowired private AuthenticationManager authenticationManager; 此时还容器中还没有authenticationManager，需要在配置类中配置\n@Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { /** *该方法会返回一个AuthenticationManager的对象 *通过bean注解注入容器 */ @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } } 调用authenticationManager的authenticate的方法，但是authenticate会调用UserDetailsService的自带方法（需要重写）去访问内存，实际需求需要去访问数据库\n@Service public class UserDetailsServiceImpl implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //根据用户名查询用户信息 LambdaQueryWrapper\u0026lt;User\u0026gt; lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper.eq(User::getUserName, username); User user = userMapper.selectOne(lambdaQueryWrapper); //判断是否查到用户，如果没查到抛出异常 if (Objects.isNull(user)) { throw new RuntimeException(\u0026#34;用户不存在\u0026#34;); } //返回用户信息 //TODO 查询权限信息封装 //LoginUser是UserDetails的实现类 return new LoginUser(user); } } 通过service注解注入容器可以实现替换原来的方法实现校验\n调用完authenticate会返回authenticate对象，继续实现login的方法\n@Service public class BlogLoginServiceImpl implements BlogLoginService { @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) { UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(usernamePasswordAuthenticationToken); //判断是否认证通过 if (Objects.isNull(authenticate)) { throw new RuntimeException(\u0026#34;用户名或密码错误\u0026#34;); } //获取userid生成token //getPrincipal是获取authenticate的主体，里面封装了之前传入的loginUser LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); //将userid加密成jwt String jwt = JwtUtil.createJWT(userId); //把用户信息存入redis redisCache.setCacheObject(\u0026#34;bolglogin:\u0026#34;+userId,loginUser); //把token和userinfo封装返回 //把User转换成UserInfoVo UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class); BlogUserLoginVo vo = new BlogUserLoginVo(jwt,userInfoVo); return ResponseResult.okResult(vo); } } 配置security配置类\n@Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(\u0026#34;/login\u0026#34;).anonymous() //jwt过滤器测试用，如果测试没有问题吧这里删除了 .antMatchers(\u0026#34;/link/getAllLink\u0026#34;).authenticated() // 除上面外的所有请求全部不需要认证即可访问 .anyRequest().permitAll(); http.logout().disable(); //允许跨域 http.cors(); } @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } 登陆校验过滤器 ​\t①定义Jwt认证过滤器\n​\t获取token\n​\t解析token获取其中的userid\n​\t从redis中获取用户信息\n​\t存入SecurityContextHolder\n配置过滤器 @Component public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException { //获取请求头中的token String token = httpServletRequest.getHeader(\u0026#34;token\u0026#34;); if (!StringUtils.hasText(token)) { filterChain.doFilter(httpServletRequest, httpServletResponse); return; } //解析获取userid Claims claims = null; try { claims = JwtUtil.parseJWT(token); } catch (Exception e) { e.printStackTrace(); //token超时，token非法 //响应告诉前端需要重新登陆 ResponseResult responseResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN); WebUtils.renderString(httpServletResponse, JSON.toJSONString(responseResult)); return; } String userId = claims.getSubject(); //从redis中获取用户信息 LoginUser loginUser = redisCache.getCacheObject(\u0026#34;bloglogin:\u0026#34; + userId); if (Objects.isNull(loginUser)) { //响应告诉前端需要重新登陆 ResponseResult responseResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN); WebUtils.renderString(httpServletResponse, JSON.toJSONString(responseResult)); return; } //存入SecurityContextHolder UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); filterChain.doFilter(httpServletRequest,httpServletResponse); } } security配置 ​\t由于重写了configure方法，UsernamepasswordAuthenticationFilter并没有加入到过滤器链中，这里addFilterBefore意思是替换UsernamepasswordAuthenticationFilter原来的位置\n@Autowired private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception { //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); } 认证失败处理 ​\t目前我们的项目在认证出错或者权限不足的时候响应回来的Json是Security的异常处理结果。但是这个响应的格式肯定是不符合我们项目的接口规范的。所以需要自定义异常处理。\n​\tAuthenticationEntryPoint 认证失败处理器\n​\tAccessDeniedHandler 授权失败处理器\nAccessDeniedHandlerImpl实现AccessDeniedHandler接口\n@Component public class AccessDeniedHandlerImpl implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException { e.printStackTrace(); ResponseResult responseResult = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH); //响应给前端 WebUtils.renderString(response, JSON.toJSONString(responseResult)); } } AuthenticationEntryPointImpl实现AuthenticationEntryPoint接口\n@Component public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException { e.printStackTrace(); ResponseResult responseResult = null; //根据错误类型返回数据 if (e instanceof BadCredentialsException) { responseResult = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR.getCode(),e.getMessage()); } else if (e instanceof InsufficientAuthenticationException) { responseResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN); } else { responseResult = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),\u0026#34;认证或授权失败\u0026#34;); } //响应给前端 WebUtils.renderString(response, JSON.toJSONString(responseResult)); } } 自定义全局异常 自定义一个异常类SystemException public class SystemException extends RuntimeException{ private int code; private String msg; public int getCode() { return code; } public String getMsg() { return msg; } public SystemException(AppHttpCodeEnum httpCodeEnum) { super(httpCodeEnum.getMsg()); this.code = httpCodeEnum.getCode(); this.msg = httpCodeEnum.getMsg(); } } 写一个handler处理抛出的异常 @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(SystemException.class) public ResponseResult systemExceptionHandler(SystemException e) { //打印异常信息 log.error(\u0026#34;出现了异常！{}\u0026#34;,e); //从异常对象中获取提示信息封装返回 return ResponseResult.errorResult(e.getCode(), e.getMsg()); } /** *定义一个handler处理其他异常 */ @ExceptionHandler(Exception.class) public ResponseResult ExceptionHandler(Exception e) { //打印异常信息 log.error(\u0026#34;出现了异常！{}\u0026#34;,e); //从异常对象中获取提示信息封装返回 return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR); } } @Slf4j：打印日志信息的注解，注解后可以通过log.error打印错误\n关闭8080端口 netstat -o -n -a | findstr :8080 taskkill /F /PID 3116\n异常处理器 自定义全局异常 用来捕获抛出的异常，其中业务异常处理器需要自定义业务异常\n/* 全局异常处理 */ @ControllerAdvice(annotations = {RestController.class, Controller.class}) @ResponseBody @Slf4j public class GlobalExceptionHandler { /** * 异常处理方法 * * @return */ @ExceptionHandler(SQLIntegrityConstraintViolationException.class) public R\u0026lt;String\u0026gt; exceptionHandler(SQLIntegrityConstraintViolationException ex) { log.error(ex.getMessage()); if (ex.getMessage().contains(\u0026#34;Duplicate entry\u0026#34;)) { String[] split = ex.getMessage().split(\u0026#34; \u0026#34;); String msg = split[2] + \u0026#34;已存在\u0026#34;; return R.error(msg); } return R.error(\u0026#34;未知错误\u0026#34;); } /** * 业务异常处理方法 * * @return */ @ExceptionHandler(CustomExpection.class) public R\u0026lt;String\u0026gt; exceptionHandler(CustomExpection ex) { log.error(ex.getMessage()); return R.error(ex.getMessage()); } } public class CustomExpection extends RuntimeException { public CustomExpection(String message) { super(message); } } 使用时需要抛出异常\nthrow new CustomExpection(\u0026#34;当前分类下关联了套餐，不能删除\u0026#34;); 使用过滤器完成登录校验 @Slf4j @WebFilter(filterName = \u0026#34;loginCheckFilter\u0026#34;,urlPatterns =\u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { //路径匹配器，支持通配符 public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher(); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //1、获取本次请求的URl String requestURl = request.getRequestURI(); log.info(\u0026#34;拦截到请求：{}\u0026#34;, request.getRequestURI()); String[] urls = new String[]{ \u0026#34;/employee/login\u0026#34;, \u0026#34;/emplyee/logout\u0026#34;, \u0026#34;/backend/**\u0026#34;, \u0026#34;/front/**\u0026#34; }; //2、判断本次请求是否需要处理 boolean check = check(urls, requestURl); //3、如果不需要处理直接放行 if (check) { log.info(\u0026#34;本次请求{}不需要处理\u0026#34;, requestURl); filterChain.doFilter(request, response); return; } //4、判断登录状态，如果已登录，直接放行 if (request.getSession().getAttribute(\u0026#34;employee\u0026#34;) != null) { Long empId=(Long) request.getSession().getAttribute(\u0026#34;employee\u0026#34;); BaseContext.setCurrentId(empId); filterChain.doFilter(request, response); return; } //5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(\u0026#34;NOTLOGIN\u0026#34;))); return; } public boolean check(String[] urls, String requestURl) { for (String url : urls) { boolean match = PATH_MATCHER.match(url, requestURl); if (match) { return true; } } return false; } } 其他 消息转换器 前端js文件对于Long型数据会产生精度丢失。解决方法使用对象映射器\nimport com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer; import java.math.BigInteger; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */ public class JacksonObjectMapper extends ObjectMapper { public static final String DEFAULT_DATE_FORMAT = \u0026#34;yyyy-MM-dd\u0026#34;; public static final String DEFAULT_DATE_TIME_FORMAT = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;; public static final String DEFAULT_TIME_FORMAT = \u0026#34;HH:mm:ss\u0026#34;; public JacksonObjectMapper() { super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(BigInteger.class, ToStringSerializer.instance) .addSerializer(Long.class, ToStringSerializer.instance) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); } } 并在WebConfig中配置\n@Configuration public class WebConfig extends WebMvcConfigurationSupport { /** *设置静态资源映射 */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/backend/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/backend/\u0026#34;); registry.addResourceHandler(\u0026#34;/front/**\u0026#34;).addResourceLocations(\u0026#34;/classpath:/front\u0026#34;); } @Override protected void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { //创建消息转化器对象 MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); //设置对象转换器，底层使用Jackson将对象转换为json messageConverter.setObjectMapper(new JacksonObjectMapper()); //将上面的消息转换器对象追加到mvc框架的转换器集合中 converters.add(0, messageConverter); } } ThreadLocal ThreadLoacal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取相应的值，线程外则不能访问\nThreadLocal常用方法\npublic void set(T value) //设置当前线程的线程局部变量的值 public T get() //返回当前线程所对应的线程局部变量的值 例：\npublic class BaseContext { private static ThreadLocal\u0026lt;Long\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); public static void setCurrentId(Long id) { threadLocal.set(id); } public static Long getCurrentId() { return threadLocal.get(); } } 静态资源映射 由于只能访问static文件下的静态资源，当需要访问其他文件夹下的静态资源需要在WebConfig里设置静态资源映射\n@Configuration public class WebConfig extends WebMvcConfigurationSupport { /** *设置静态资源映射 */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/backend/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/backend/\u0026#34;); registry.addResourceHandler(\u0026#34;/front/**\u0026#34;).addResourceLocations(\u0026#34;/classpath:/front\u0026#34;); } } Spring Cache @EnableCaching ：开启缓存注解功能\n在controller方法上加入以下注解：\n@Cacheable：在方法执行之前spring先查看缓存中是否有数据，如果有数据则直接返回数据；若没有数据，调用方法并将返回值放到缓存中(value=\u0026quot;?\u0026quot;,key=\u0026quot;#result.?\u0026quot;,unless=\u0026ldquo;result==null\u0026rdquo;)，unless满足条件不缓存\n@CachePut：将方法的返回值放到缓存中(value=\u0026quot;?\u0026quot;,key=\u0026quot;#result.?\u0026quot;),value是指缓存的名称，key是缓存的键\n@CacheEvict：将一条或多条数据从缓存中删除(value=\u0026quot;?\u0026quot;,key=\u0026quot;#root.args[0]\u0026quot; or \u0026ldquo;#id\u0026rdquo;)，allEntries = true删除这个分类下所有的缓存数据\n在启动类上使用@EnableCaching开启缓存支持\n使用redis作为缓存技术，只需要导入Spring data Redis 的maven坐标:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置redis=》application.yml\nspring: cache: redis: time-to-live:1800000#设置缓存有效期ms @Autowired private CacheManager cacheManaget swagger 1、导入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、导入knife4j相关配置（WebMvcConfig）\n@EnableSwagger2\n@EnableKnife4j\n@Bean public Docket createRestApi() { //文档类型 return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.itheima.reggie.controller\u0026#34;)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\u0026#34;瑞吉外卖\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .description(\u0026#34;瑞吉外卖接口文档\u0026#34;) .build(); } 3、设置静态资源映射\nregistry.addResourceHandler(\u0026#34;doc.html\u0026#34;).addResourceLocations(\u0026#34;classpath:/META-INF/resources/\u0026#34;); registry.addResourceHandler(\u0026#34;/webjars/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;); 4、过滤器中设置不需要处理的请求路径\nString[] urls = new String[]{ \u0026#34;/employee/login\u0026#34;, \u0026#34;/employee/logout\u0026#34;, \u0026#34;/backend/**\u0026#34;, \u0026#34;/front/**\u0026#34;, \u0026#34;/common/**\u0026#34;, \u0026#34;/user/sendMsg\u0026#34;, \u0026#34;/user/login\u0026#34;, \u0026#34;/doc.html\u0026#34;, \u0026#34;/webjars/**\u0026#34;, \u0026#34;/swagger-resources\u0026#34;, \u0026#34;/v2/api-docs\u0026#34; }; swaggerApi ","permalink":"answerboom.github.io/articles/2022/12/27/blognote/","summary":"blog项目笔记 mybatis plus 1. 类注解 @Data @NoArgsConstructor @AllArgsConstructor @TableName(\u0026#34;sg_article\u0026#34;) @Accessors(chain = true) public class Article{ } @Data：注在类上，提供类的get、set、equals、hashCode、toString方法\n@NoArgsConstructor：提供类的无参构造\n@AllArgsConstructor：提供类的全参构造\n@TableName(\u0026quot;sg_article\u0026quot;)：将表与数据库里的表对应起来\n@Accessors(chain = true)：将get、set方法的返回类型设置为实体类对象，代替了默认的返回void\n实体类中加入数据库中不存在的列名需要加入TableField注解标识\n@TableField(exist = false) private String categoryName; 2. mybatis plus中wapper方法 queryWapper.eq（字段名，val）\n字段名可以用字符串也可以用方法：Article::getStatus\n推荐用方法防止列名写错\nlambdaQueryWrapper.eq(Objects.nonNull(categoryId) \u0026amp;\u0026amp; categoryId \u0026gt; 0, Article::getCategoryId, categoryId);\neq方法中有三个参数，第一个boolean为true时引入加入后两个参数条件，为false时不加入\n3. 使用page分页需要配置分页插件，在config包下加入以下类 @Configuration public class MbatisPlusConfig { /** * 3.4.0之后版本 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; } } 4、公共字段填充 插入时间、更新时间的自动填充","title":"Blog笔记"},{"content":"ruoyi实现不需要token访问静态资源 在config/SecurityConfig配置\n.antMatchers( HttpMethod.GET, \u0026#34;/\u0026#34;, \u0026#34;/*.html\u0026#34;, \u0026#34;/**/*.html\u0026#34;, \u0026#34;/**/*.css\u0026#34;, \u0026#34;/**/*.js\u0026#34;, //profile下有很多文件，只开放头像类的文件 \u0026#34;/profile/upload/**\u0026#34;, \u0026#34;/profile/**\u0026#34;, \u0026#34;/profile/avatar/**\u0026#34; \u0026ldquo;/xxx/**\u0026ldquo;让xxx路径下的全部文件访问不需要token\n在config/ResourcesConfig中增加\n/** 本地文件上传路径 */ registry.addResourceHandler(Constants.RESOURCE_PREFIX + \u0026#34;/**\u0026#34;) .addResourceLocations(\u0026#34;file:\u0026#34; + RuoYiConfig.getProfile() + \u0026#34;/\u0026#34;); 前端加入Element Ui upload组件组件 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;dasd\u0026#34;\u0026gt; \u0026lt;el-upload class=\u0026#34;img-upload\u0026#34; ref=\u0026#34;upload\u0026#34; action=\u0026#34;http://localhost:8080/dss/ServiceStd/uploadimg\u0026#34; :on-preview=\u0026#34;handlePreview\u0026#34; :on-remove=\u0026#34;handleRemove\u0026#34; :headers=\u0026#34;header\u0026#34; :before-remove=\u0026#34;beforeRemove\u0026#34; :on-success=\u0026#34;handleSuccess\u0026#34; multiple :limit=\u0026#34;1\u0026#34; :on-exceed=\u0026#34;handleExceed\u0026#34; :file-list=\u0026#34;fileList\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;点击上传\u0026lt;/el-button\u0026gt; \u0026lt;div slot=\u0026#34;tip\u0026#34; class=\u0026#34;el-upload__tip\u0026#34;\u0026gt;只能上传jpg/png文件，且不超过500kb\u0026lt;/div\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { getToken } from \u0026#39;@/utils/auth\u0026#39;; export default { name: \u0026#39;ImgUpload\u0026#39;, data () { return { fileList: [], url: \u0026#39;\u0026#39;, header: { Authorization: \u0026#39;Bearer \u0026#39; + getToken() } } }, methods: { handleRemove (file, fileList) { this.$emit(\u0026#34;clearImageUrl\u0026#34;) }, handlePreview (file) { }, handleExceed (files, fileList) { this.$message.warning(`当前限制选择 1 个文件，本次选择了 ${files.length} 个文件，共选择了 ${files.length + fileList.length} 个文件`) }, beforeRemove (file, fileList) { return this.$confirm(`确定移除 ${file.name}？`) }, handleSuccess (response) { this.url = response this.$emit(\u0026#39;onUpload\u0026#39;) this.$message.warning(\u0026#39;上传成功\u0026#39;) }, clear () { this.$refs.upload.clearFiles() }, } } \u0026lt;/script\u0026gt; 解决Element ui上传图片时未携带token访问不到服务器问题 在data()里面加入header属性设置子属性Authorization\ndata () { return { header: { Authorization: \u0026#39;Bearer \u0026#39; + getToken() } } 在el-upload里设置\n\u0026lt;el-upload :headers=\u0026#34;header\u0026#34; \u0026gt; 解决upload组件重新进入上传时清除上次上传 在提交时\n\u0026lt;el-form-item label=\u0026#34;作业标准示范\u0026#34; prop=\u0026#34;OpeStdThr\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.OpeStd\u0026#34; autocomplete=\u0026#34;off\u0026#34; placeholder=\u0026#34;图片 URL\u0026#34; readonly\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;img-upload @onUpload=\u0026#34;uploadImg\u0026#34; ref=\u0026#34;imgUpload\u0026#34; @clearImageUrl=\u0026#34;clearImageUrl(1)\u0026#34;\u0026gt;\u0026lt;/img-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; 在提交时新增clear()方法调用子组件里clear方法\nsubmitForm: function () { this.$refs.imgUpload.clear(); } 删除图片时同时删除URl 加入@clearImageUrl绑定方法\n\u0026lt;el-form-item label=\u0026#34;作业标准示范\u0026#34; prop=\u0026#34;OpeStdThr\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.OpeStd\u0026#34; autocomplete=\u0026#34;off\u0026#34; placeholder=\u0026#34;图片 URL\u0026#34; readonly\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;img-upload @onUpload=\u0026#34;uploadImg\u0026#34; ref=\u0026#34;imgUpload\u0026#34; @clearImageUrl=\u0026#34;clearImageUrl(1)\u0026#34;\u0026gt;\u0026lt;/img-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; clearImageUrl(1) 括号内可以直接携带参数，根据参数执行哪种方法\nclearImageUrl(type) { if (type == 1) { //delImgUrl调用后端接口删除已上传的照片 delImgUrl(this.form.OpeStdOne); this.form.OpeStdOne = \u0026#39;\u0026#39;; }else if (type ==2) { delImgUrl(this.form.OpeStdTwo); this.form.OpeStdTwo = \u0026#39;\u0026#39;; }else if (type == 3) { delImgUrl(this.form.OpeStdThr); this.form.OpeStdThr = \u0026#39;\u0026#39;; } } delImgUrl可以采用两种方式 使用缓存，到了一定图片数量再去删除 直接去后台删除 ","permalink":"answerboom.github.io/articles/2022/10/21/elementuiimageupload/","summary":"ruoyi实现不需要token访问静态资源 在config/SecurityConfig配置\n.antMatchers( HttpMethod.GET, \u0026#34;/\u0026#34;, \u0026#34;/*.html\u0026#34;, \u0026#34;/**/*.html\u0026#34;, \u0026#34;/**/*.css\u0026#34;, \u0026#34;/**/*.js\u0026#34;, //profile下有很多文件，只开放头像类的文件 \u0026#34;/profile/upload/**\u0026#34;, \u0026#34;/profile/**\u0026#34;, \u0026#34;/profile/avatar/**\u0026#34; \u0026ldquo;/xxx/**\u0026ldquo;让xxx路径下的全部文件访问不需要token\n在config/ResourcesConfig中增加\n/** 本地文件上传路径 */ registry.addResourceHandler(Constants.RESOURCE_PREFIX + \u0026#34;/**\u0026#34;) .addResourceLocations(\u0026#34;file:\u0026#34; + RuoYiConfig.getProfile() + \u0026#34;/\u0026#34;); 前端加入Element Ui upload组件组件 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;dasd\u0026#34;\u0026gt; \u0026lt;el-upload class=\u0026#34;img-upload\u0026#34; ref=\u0026#34;upload\u0026#34; action=\u0026#34;http://localhost:8080/dss/ServiceStd/uploadimg\u0026#34; :on-preview=\u0026#34;handlePreview\u0026#34; :on-remove=\u0026#34;handleRemove\u0026#34; :headers=\u0026#34;header\u0026#34; :before-remove=\u0026#34;beforeRemove\u0026#34; :on-success=\u0026#34;handleSuccess\u0026#34; multiple :limit=\u0026#34;1\u0026#34; :on-exceed=\u0026#34;handleExceed\u0026#34; :file-list=\u0026#34;fileList\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;点击上传\u0026lt;/el-button\u0026gt; \u0026lt;div slot=\u0026#34;tip\u0026#34; class=\u0026#34;el-upload__tip\u0026#34;\u0026gt;只能上传jpg/png文件，且不超过500kb\u0026lt;/div\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { getToken } from \u0026#39;@/utils/auth\u0026#39;; export default { name: \u0026#39;ImgUpload\u0026#39;, data () { return { fileList: [], url: \u0026#39;\u0026#39;, header: { Authorization: \u0026#39;Bearer \u0026#39; + getToken() } } }, methods: { handleRemove (file, fileList) { this.","title":"ElementUi图片上传"},{"content":"leetcode存在重复元素： 昨天写了leetcode存在重复元素问题，一开始暴力求解用两个for循环，时间复杂度太高了，想了想用快速排序，看了题解，题解直接调用c语言的qsort函数，于是手写了一个简单的快速排序算法，一开始栈上溢，发现是快速排序传入参数，数组的长度numsize直接作为数组的最后一个元素\nbool containsDuplicate(int* nums, int numsSize){ quicksort(nums,0,numsSize); 后来在quicksort内修改\nint temp; int i=low,j=high-1; if(low\u0026lt;high){ 发现输出结果，基准值右边的两个数不会调换次序\n如：输入{0，3，4，1，6，5} 得到输出{0，3，1，4，5，6} 最后发现原来是j=high-1，每次递归会使high-1， 当最后一个子数组只剩2个元素时，high-1=low，使得最后的数组元素不会比较大小直接返回上次递归\n修改后提交代码如下\nvoid quicksort(int nums[],int low,int high){ int temp; int i=low,j=high; if(low\u0026lt;high){ temp=nums[i]; while(i\u0026lt;j){ while(j\u0026gt;i\u0026amp;\u0026amp;nums[j]\u0026gt;=temp)j--; if(j\u0026gt;i){ nums[i]=nums[j]; i++; } while(i\u0026lt;j\u0026amp;\u0026amp;nums[i]\u0026lt;=temp)i++; if(i\u0026lt;j){ nums[j]=nums[i]; j--; } } nums[i]=temp; quicksort(nums,low,i-1); quicksort(nums,i+1,high); } } bool containsDuplicate(int* nums, int numsSize){ int i; quicksort(nums,0,numsSize-1); for(i=0;i\u0026lt;numsSize-1;i++){ if(nums[i]==nums[i+1]){ return true; } } return false; } 提交时间复杂度还是太高，就像能不能在快速排序的时候就进行判断，如果排序时候遇到相同的数直接返回ture，这里一开始写返回false但是最后递归的时候深层的递归返回不会结束整个递归，只是结束当前递归返回上次递归，而最后的结果会被最上层的递归覆盖掉，于是加了if判断，若下层递归为ture及存在重复元素，直接返回ture， 代码如下\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; bool quicksort(int nums[],int low,int high){ int temp; int i=low,j=high; if(low\u0026lt;high){ temp=nums[i]; while(i\u0026lt;j){ while(j\u0026gt;i\u0026amp;\u0026amp;nums[j]\u0026gt;=temp){ if(nums[j]==temp) { return true; } j--; } if(j\u0026gt;i){ nums[i]=nums[j]; i++; } while(i\u0026lt;j\u0026amp;\u0026amp;nums[i]\u0026lt;=temp) { if(nums[i]==temp) { return true; } i++; } if(i\u0026lt;j){ nums[j]=nums[i]; j--; } } nums[i]=temp; if(quicksort(nums,low,i-1))return true; if(quicksort(nums,i+1,high))return true; } return false; } bool containsDuplicate(int* nums, int numsSize){ int i; if(quicksort(nums,0,numsSize-1)){ return true; } // for(i=0;i\u0026lt;numsSize-1;i++){ // if(nums[i]==nums[i+1]){ // return true; // } // } return false; } 结果提交时间还是超了，这里对快速排序的优化并不能提高快速排序的平均复杂度nlogn，当数组很大且重复的数出现在靠后位置时，只是省略了快速排序后的单次循环，而快速排序本身的时间复杂度趋向n^2.\n在最优情况下，每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为 [log2n]+1（ [x] 表示不大于 x 的最大整数），即仅需递归 log2n 次，需要时间为T（n）的话，第一次应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。\n快速排序最坏情况 当待排序的序列为正序或逆序排列时，且每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为 ，最终其时间复杂度为O(n^2)。\n很纳闷，于是查看了c语言提供的qsort源码，发现qsort并不是简单的快速排序，而是在快速排序的基础上进行了优化。\n还是太年轻了。\n","permalink":"answerboom.github.io/articles/2021/10/01/leetcoderepeatingelement/","summary":"leetcode存在重复元素： 昨天写了leetcode存在重复元素问题，一开始暴力求解用两个for循环，时间复杂度太高了，想了想用快速排序，看了题解，题解直接调用c语言的qsort函数，于是手写了一个简单的快速排序算法，一开始栈上溢，发现是快速排序传入参数，数组的长度numsize直接作为数组的最后一个元素\nbool containsDuplicate(int* nums, int numsSize){ quicksort(nums,0,numsSize); 后来在quicksort内修改\nint temp; int i=low,j=high-1; if(low\u0026lt;high){ 发现输出结果，基准值右边的两个数不会调换次序\n如：输入{0，3，4，1，6，5} 得到输出{0，3，1，4，5，6} 最后发现原来是j=high-1，每次递归会使high-1， 当最后一个子数组只剩2个元素时，high-1=low，使得最后的数组元素不会比较大小直接返回上次递归\n修改后提交代码如下\nvoid quicksort(int nums[],int low,int high){ int temp; int i=low,j=high; if(low\u0026lt;high){ temp=nums[i]; while(i\u0026lt;j){ while(j\u0026gt;i\u0026amp;\u0026amp;nums[j]\u0026gt;=temp)j--; if(j\u0026gt;i){ nums[i]=nums[j]; i++; } while(i\u0026lt;j\u0026amp;\u0026amp;nums[i]\u0026lt;=temp)i++; if(i\u0026lt;j){ nums[j]=nums[i]; j--; } } nums[i]=temp; quicksort(nums,low,i-1); quicksort(nums,i+1,high); } } bool containsDuplicate(int* nums, int numsSize){ int i; quicksort(nums,0,numsSize-1); for(i=0;i\u0026lt;numsSize-1;i++){ if(nums[i]==nums[i+1]){ return true; } } return false; } 提交时间复杂度还是太高，就像能不能在快速排序的时候就进行判断，如果排序时候遇到相同的数直接返回ture，这里一开始写返回false但是最后递归的时候深层的递归返回不会结束整个递归，只是结束当前递归返回上次递归，而最后的结果会被最上层的递归覆盖掉，于是加了if判断，若下层递归为ture及存在重复元素，直接返回ture， 代码如下\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.","title":"Leetcode 重复元素"}]